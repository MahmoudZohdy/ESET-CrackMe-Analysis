// VMDisassembler.cpp : This file contains Dis assembler for the VM
//

#include <iostream>
#include <Windows.h>
#include <string>
using namespace std;

//Second VM
unsigned char VMCode[256] = {
	0x0B, 0x60, 0x00, 0x01, 0x01, 0x05, 0x20, 0x01, 0x01, 0x02, 0x00, 0x01, 0x10, 0x04, 0x0A, 0x10,
	0x12, 0x01, 0x0A, 0x11, 0x12, 0x01, 0x06, 0x01, 0x26, 0x00, 0x01, 0x07, 0x01, 0x0B, 0x00, 0x00,
	0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x01, 0x02, 0x00, 0x01, 0xC4, 0x20, 0x01, 0x4E, 0x20, 0x0A,
	0xDE, 0x18, 0x06, 0xE4, 0x18, 0x07, 0x01, 0x3E, 0x00, 0x00, 0x00, 0x01, 0xC4, 0x20, 0x01, 0x53,
	0x20, 0x0A, 0x03, 0x18, 0x0A, 0x31, 0x11, 0x0A, 0x41, 0x11, 0x0A, 0x01, 0x76, 0x00, 0x01, 0x01,
	0x53, 0x20, 0x0A, 0x03, 0x18, 0x01, 0x5F, 0x20, 0x0A, 0x1F, 0x18, 0x01, 0x32, 0x01, 0x01, 0xF3,
	0x05, 0x01, 0x2F, 0x04, 0x0A, 0x10, 0x12, 0x01, 0x0A, 0x14, 0x12, 0x01, 0x06, 0x00, 0x26, 0x00,
	0x01, 0x07, 0x01, 0x32, 0x00, 0x00, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x01, 0x02, 0x00, 0x01,
	0xA3, 0x20, 0x01, 0x34, 0x20, 0x0A, 0xB4, 0x18, 0x06, 0x43, 0x08, 0x07, 0x01, 0xDC, 0x00, 0x00,
	0x00, 0x0A, 0x10, 0x12, 0x01, 0x0A, 0x00, 0x76, 0x00, 0x01, 0x01, 0x52, 0x20, 0x0A, 0x02, 0x18,
	0x0A, 0x21, 0x11, 0x0A, 0x01, 0x76, 0x00, 0x01, 0x01, 0x5E, 0x20, 0x0A, 0x1E, 0x18, 0x01, 0x2F,
	0x01, 0x01, 0xE2, 0x05, 0x01, 0xFE, 0x04, 0x01, 0x0F, 0x02, 0x00, 0x0A, 0x2F, 0x11, 0x0A, 0xEF,
	0x11, 0x0A, 0x0F, 0x76, 0x00, 0x01, 0x0A, 0x5F, 0x18, 0x01, 0xFF, 0x01, 0x0A, 0x3F, 0x01, 0x01,
	0xF3, 0x04, 0x0A, 0x13, 0x12, 0x01, 0x07, 0x00, 0x88, 0x00, 0x00, 0x00, 0x0C, 0x85, 0x00, 0x88,
	0x28, 0x00, 0x17, 0x04, 0x46, 0x69, 0x6C, 0xE5, 0x00, 0x04, 0x00, 0x00, 0xF8, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// Second VM  decryptor

/*unsigned char VMCode[256] = {
	0x01, 0x70, 0x20, 0x01, 0x01, 0x01, 0x0A, 0x00, 0x12, 0x01, 0x01, 0x02, 0x01, 0x0A, 0x00, 0x12,
	0x05, 0x01, 0x03, 0x21, 0x01, 0x80, 0x20, 0x0A, 0x70, 0x18, 0x0A, 0x73, 0x18, 0x01, 0x34, 0x01,
	0x0A, 0x14, 0x08, 0x0A, 0x21, 0x18, 0x01, 0x43, 0x04, 0x0A, 0x03, 0x12, 0x01, 0x06, 0x03, 0x28,
	0x07, 0x01, 0x1D, 0x00, 0x00, 0x00, 0x01, 0x70, 0x20, 0x01, 0x00, 0x06, 0x37, 0x0A, 0x00, 0x12,
	0x01, 0x01, 0x00, 0x06, 0x13, 0x00, 0x17, 0x04, 0xAC, 0xF5, 0x3D, 0x81, 0xEC, 0x15, 0x5D, 0xA6,
	0xEC, 0x35, 0x6C, 0xC0, 0x06, 0x44, 0x8E, 0xE5, 0x26, 0x65, 0xAE, 0x05, 0x4A, 0x95, 0xFA, 0x24,
	0x6D, 0xB3, 0xFD, 0x4F, 0x8C, 0xD4, 0x1C, 0x65, 0xAC, 0xF6, 0x3C, 0x85, 0xCD, 0x16, 0x5C, 0xA5,
	0x28, 0x14, 0x7D, 0x8A, 0x2C, 0x5E, 0x42, 0xFC, 0x2A, 0x90, 0xA4, 0x03, 0x4D, 0xAA, 0xDC, 0x24,
	0x6C, 0xB5, 0x38, 0x64, 0x8D, 0x87, 0x3C, 0x6E, 0xAF, 0xEC, 0x36, 0xB5, 0xDD, 0x1E, 0x1D, 0xB5,
	0xE6, 0x35, 0x0A, 0xC4, 0x0D, 0x55, 0xCF, 0xC4, 0x26, 0x77, 0xA4, 0x05, 0x13, 0xB4, 0xD6, 0x3B,
	0x74, 0xB5, 0xCE, 0x45, 0x8D, 0x27, 0x19, 0x65, 0x83, 0xF0, 0x36, 0x94, 0xDE, 0x15, 0x56, 0xB0,
	0xFE, 0x35, 0x7A, 0xC4, 0x2A, 0x54, 0x9D, 0xE3, 0x2D, 0x46, 0xBC, 0x04, 0x4C, 0x95, 0xDC, 0x26,
	0x6C, 0xB5, 0xFD, 0x46, 0x8C, 0xD5, 0xBF, 0x44, 0xAD, 0xC0, 0x1C, 0x8E, 0x78, 0x0C, 0x5A, 0xE7,
	0xE4, 0x33, 0x7D, 0x18, 0x0C, 0x54, 0x9C, 0xEE, 0x3C, 0x66, 0xBD, 0x0E, 0x4C, 0xE2, 0xDC, 0x25,
	0x6D, 0xE6, 0xDC, 0x4E, 0x8E, 0xCC, 0x16, 0x45, 0xBD, 0xFE, 0x3D, 0xF2, 0xCC, 0x15, 0x5D, 0xFA,
	0xCC, 0x3E, 0x62, 0xDC, 0x0D, 0x7B, 0x9D, 0xE5, 0xCE, 0x71, 0xBD, 0xFA, 0x48, 0x95, 0xD3, 0x26
};*/

// First VM Code
/*unsigned char VMCode[1280] = {
	0x06, 0x0C, 0x02, 0x00, 0x07, 0x01, 0x8A, 0x00, 0x00, 0x00, 0x06, 0x0D, 0x02, 0x00, 0x07, 0x01,
	0x1E, 0x01, 0x00, 0x00, 0x01, 0xC2, 0x20, 0x01, 0x13, 0x23, 0x64, 0x01, 0x00, 0x00, 0x01, 0xC4,
	0x23, 0x37, 0x01, 0x00, 0x00, 0x01, 0x25, 0x20, 0x0A, 0xD5, 0x18, 0x01, 0x3E, 0x20, 0x01, 0xE0,
	0x23, 0x60, 0x01, 0x00, 0x00, 0x0A, 0x0E, 0x19, 0x01, 0x4F, 0x20, 0x0A, 0x4F, 0x12, 0x04, 0x06,
	0x52, 0x18, 0x07, 0x01, 0x4B, 0x00, 0x00, 0x00, 0x01, 0xC2, 0x20, 0x06, 0xF4, 0x18, 0x07, 0x01,
	0x5B, 0x00, 0x00, 0x00, 0x01, 0x54, 0x23, 0x37, 0x01, 0x00, 0x00, 0x06, 0xE3, 0x08, 0x07, 0x01,
	0x00, 0x01, 0x00, 0x00, 0x01, 0x20, 0x01, 0x0A, 0x30, 0x01, 0x0A, 0x10, 0x12, 0x01, 0x0A, 0x10,
	0x52, 0x01, 0x0A, 0x40, 0x01, 0x01, 0x03, 0x04, 0x0A, 0x12, 0x12, 0x01, 0x0A, 0x13, 0x12, 0x01,
	0x0A, 0x14, 0x12, 0x01, 0x07, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x01, 0xA3, 0x23, 0x40, 0x01, 0x00,
	0x00, 0x01, 0x14, 0x23, 0x37, 0x01, 0x00, 0x00, 0x01, 0x3E, 0x20, 0x01, 0x00, 0x23, 0x3C, 0x01,
	0x00, 0x00, 0x0A, 0x0E, 0x19, 0x01, 0x4F, 0x20, 0x0A, 0x4F, 0x12, 0x04, 0x06, 0xF4, 0x18, 0x07,
	0x01, 0xBC, 0x00, 0x00, 0x00, 0x01, 0xA4, 0x23, 0x37, 0x01, 0x00, 0x00, 0x06, 0xE3, 0x08, 0x07,
	0x01, 0xE8, 0x00, 0x00, 0x00, 0x01, 0x00, 0x02, 0x00, 0x0A, 0x30, 0x01, 0x0A, 0x10, 0x12, 0x01,
	0x0A, 0x10, 0x52, 0x01, 0x0A, 0x40, 0x01, 0x01, 0x03, 0x04, 0x0A, 0x13, 0x12, 0x01, 0x0A, 0x14,
	0x12, 0x01, 0x07, 0x00, 0xAC, 0x00, 0x00, 0x00, 0x01, 0xF0, 0x23, 0x3C, 0x01, 0x00, 0x00, 0x01,
	0x00, 0x21, 0x04, 0x80, 0x04, 0xB9, 0x40, 0x01, 0x00, 0x00, 0x07, 0x00, 0x12, 0x01, 0x00, 0x00,
	0x01, 0xC0, 0x23, 0x60, 0x01, 0x00, 0x00, 0x01, 0x00, 0x21, 0x04, 0x80, 0x04, 0xB1, 0x64, 0x01,
	0x00, 0x00, 0x04, 0x8B, 0x04, 0x8A, 0x0D, 0x47, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x1C,
	0x48, 0x37, 0x01, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 0x37, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00,
	0x00, 0x01, 0x70, 0x20, 0x01, 0x01, 0x01, 0x0A, 0x00, 0x12, 0x01, 0x01, 0x02, 0x01, 0x0A, 0x00,
	0x12, 0x05, 0x01, 0x03, 0x21, 0x01, 0x80, 0x20, 0x0A, 0x70, 0x18, 0x0A, 0x73, 0x18, 0x01, 0x34,
	0x01, 0x0A, 0x14, 0x08, 0x0A, 0x21, 0x18, 0x01, 0x43, 0x04, 0x0A, 0x03, 0x12, 0x01, 0x06, 0x03,
	0x28, 0x07, 0x01, 0x1D, 0x00, 0x00, 0x00, 0x01, 0x70, 0x20, 0x01, 0x00, 0x06, 0x37, 0x0A, 0x00,
	0x12, 0x01, 0x01, 0x00, 0x06, 0x13, 0x00, 0x17, 0x04, 0xAC, 0xF5, 0x3D, 0x81, 0xEC, 0x15, 0x5D,
	0xA6, 0xEC, 0x35, 0x6C, 0xC0, 0x06, 0x44, 0x8E, 0xE5, 0x26, 0x65, 0xAE, 0x05, 0x4A, 0x95, 0xFA,
	0x24, 0x6D, 0xB3, 0xFD, 0x4F, 0x8C, 0xD4, 0x1C, 0x65, 0xAC, 0xF6, 0x3C, 0x85, 0xCD, 0x16, 0x5C,
	0xA5, 0x28, 0x14, 0x7D, 0x8A, 0x2C, 0x5E, 0x42, 0xFC, 0x2A, 0x90, 0xA4, 0x03, 0x4D, 0xAA, 0xDC,
	0x24, 0x6C, 0xB5, 0x38, 0x64, 0x8D, 0x87, 0x3C, 0x6E, 0xAF, 0xEC, 0x36, 0xB5, 0xDD, 0x1E, 0x1D,
	0xB5, 0xE6, 0x35, 0x0A, 0xC4, 0x0D, 0x55, 0xCF, 0xC4, 0x26, 0x77, 0xA4, 0x05, 0x13, 0xB4, 0xD6,
	0x3B, 0x74, 0xB5, 0xCE, 0x45, 0x8D, 0x27, 0x19, 0x65, 0x83, 0xF0, 0x36, 0x94, 0xDE, 0x15, 0x56,
	0xB0, 0xFE, 0x35, 0x7A, 0xC4, 0x2A, 0x54, 0x9D, 0xE3, 0x2D, 0x46, 0xBC, 0x04, 0x4C, 0x95, 0xDC,
	0x26, 0x6C, 0xB5, 0xFD, 0x46, 0x8C, 0xD5, 0xBF, 0x44, 0xAD, 0xC0, 0x1C, 0x8E, 0x78, 0x0C, 0x5A,
	0xE7, 0xE4, 0x33, 0x7D, 0x18, 0x0C, 0x54, 0x9C, 0xEE, 0x3C, 0x66, 0xBD, 0x0E, 0x4C, 0xE2, 0xDC,
	0x25, 0x6D, 0xE6, 0xDC, 0x4E, 0x8E, 0xCC, 0x16, 0x45, 0xBD, 0xFE, 0x3D, 0xF2, 0xCC, 0x15, 0x5D,
	0xFA, 0xCC, 0x3E, 0x62, 0xDC, 0x0D, 0x7B, 0x9D, 0xE5, 0xCE, 0x71, 0xBD, 0xFA, 0x48, 0x95, 0xD3,
	0x26, 0x6C, 0xBE, 0xD3, 0x55, 0x86, 0x3B, 0x0D, 0x6E, 0xA3, 0x82, 0x3C, 0x85, 0xC6, 0x4B, 0x44,
	0xA5, 0x13, 0x35, 0x76, 0xFB, 0x0D, 0x55, 0x6F, 0xE0, 0x26, 0x67, 0xAE, 0x05, 0x4B, 0x94, 0x54,
	0x24, 0x6C, 0xB4, 0xF0, 0xC1, 0x8C, 0x45, 0x54, 0x53, 0x45, 0x00, 0x12, 0x00, 0x00, 0x00, 0x82,
	0x99, 0x8F, 0x92, 0x11, 0x9E, 0x18, 0x94, 0xB1, 0x8E, 0x8F, 0x11, 0x16, 0x9C, 0x11, 0x1A, 0x16,
	0x9D, 0xA8, 0xA1, 0xA1, 0x29, 0xA8, 0xA1, 0xA1, 0x29, 0xA8, 0xA1, 0xA1, 0x29, 0xA8, 0xA1, 0x12,
	0x00, 0x00, 0x00, 0xD0, 0xFC, 0xF9, 0xF7, 0x63, 0xED, 0x71, 0xFA, 0xD6, 0xAE, 0xE6, 0x62, 0x36,
	0xFB, 0x63, 0x7F, 0x77, 0xE9, 0x21, 0x54, 0x78, 0xA1, 0x95, 0x43, 0x64, 0x84, 0x73, 0x10, 0x12,
	0x78, 0x31, 0x40, 0x00, 0x00, 0x00, 0x58, 0x00, 0x09, 0x04, 0x56, 0x61, 0x64, 0x20, 0x08, 0xD0,
	0x55, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x42, 0x07, 0x00, 0x97, 0x42,
	0x07, 0x00, 0x02, 0x00, 0x20, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x40, 0x78, 0x4E, 0x52, 0x88, 0xA8, 0x48, 0xEE, 0x96, 0xFC, 0xFF, 0xFF, 0xFF, 0x70, 0x4E,
	0x52, 0x88, 0x70, 0x4E, 0x52, 0x88, 0x21, 0x1D, 0xCF, 0x85, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00,
	0x09, 0x04, 0x56, 0x61, 0x64, 0x20, 0x61, 0xA4, 0x52, 0x88, 0x00, 0x00, 0x00, 0x00, 0x40, 0x93,
	0xCC, 0x85, 0x20, 0x02, 0x07, 0x00, 0x36, 0x02, 0x07, 0x00, 0x11, 0x00, 0x20, 0x07, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x58, 0xA3, 0x52, 0x88, 0xD0, 0x6B,
	0xFF, 0x96, 0xFC, 0xFF, 0xFF, 0xFF, 0x50, 0xA3, 0x52, 0x88, 0x50, 0xD1, 0x57, 0x88, 0x21, 0x1D,
	0xCF, 0x85, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x03, 0x04, 0x4D, 0x6D, 0x53, 0x69, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xB7, 0xA3, 0x01, 0x00, 0x00, 0x00, 0x20, 0x1D, 0xCF, 0x85, 0x03, 0x00,
	0x0D, 0x04, 0x46, 0x4D, 0x73, 0x6C, 0x01, 0xF2, 0x60, 0x00, 0xF4, 0x95, 0xAD, 0xA3, 0xF4, 0x95,
	0xAD, 0xA3, 0x08, 0xE0, 0x9A, 0x85, 0xC8, 0x95, 0xAD, 0xA3, 0x5A, 0xC9, 0xE7, 0x89, 0x20, 0x3D,
	0x1C, 0x88, 0xC0, 0x7E, 0x52, 0x88, 0x11, 0x02, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xA4, 0x8A, 0xAD, 0xA3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x08, 0x55, 0xFF, 0x96, 0x03, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x38, 0xBA, 0x52, 0x88, 0x0D, 0x00, 0x01, 0x00, 0x45, 0x76, 0x65, 0xEE, 0x01, 0x00,
	0x20, 0x04, 0x4E, 0x53, 0x49, 0x6B, 0x88, 0x04, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00,
	0x00, 0x00, 0x88, 0xBA, 0x52, 0x88, 0x02, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x90, 0xBA,
	0x52, 0x88, 0x02, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x04, 0x20, 0xE0, 0x00, 0x94, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00,
	0x00, 0x00, 0xE0, 0xBA, 0x52, 0x88, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x02, 0x01,
	0x00, 0x00, 0xF8, 0xBA, 0x52, 0x88, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
	0x00, 0x00, 0x3A, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0xE8, 0xBA, 0x52, 0x88, 0x53, 0x00,
	0x79, 0x00, 0x73, 0x00, 0x74, 0x00, 0x65, 0x00, 0x6D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0B, 0x00,
	0x00, 0x00, 0x08, 0xBB, 0x52, 0x88, 0x0B, 0x00, 0x00, 0x00, 0x18, 0xBB, 0x52, 0x88, 0xFE, 0x80,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x80,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x28, 0xBB,
	0x52, 0x88, 0x50, 0xBA, 0x52, 0x88, 0x28, 0xBB, 0x52, 0x88, 0x00, 0x00, 0x00, 0x00, 0x4C, 0x4D,
	0x45, 0x4D, 0xE8, 0x00, 0x00, 0x00, 0xC4, 0x00, 0x73, 0x88, 0xD0, 0x94, 0x1F, 0x88, 0x20, 0x00,
	0x0A, 0x04, 0x56, 0x61, 0x64, 0x6C, 0x5B, 0x2A, 0xD5, 0x85, 0xC0, 0x78, 0xD4, 0x85, 0x00, 0x00,
	0x00, 0x00, 0xDA, 0xFF, 0x07, 0x00, 0xDA, 0xFF, 0x07, 0x00, 0x01, 0x00, 0x88, 0x84, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};*/
int CodeSize = 0x100;
int CurrentIP = 0;

int GetOperand(DWORD baseofCode, int First, int Second, int Third);

bool flag_ = 1;

int ComparesonType = -1;

int main()
{
	string Commands[] = { "CMP " ,"JUMP ","MOV ","PUSH " };
	string Conditional = "Conditional";
	string Registers[] = { "R0" ,"R1","R2","R3","R4","R5","R6","R7","R8","R9","R10","R11","R12","R13","R14","R15" };


	while (true)
	{
		if (CurrentIP > CodeSize) {
			break;
		}

		switch (VMCode[CurrentIP])
		{
		case 0x06:	//cmp
		{
			int start = CurrentIP;
			string FinalCode = Commands[0];
			CurrentIP++;
			BYTE temp = VMCode[CurrentIP++];
			BYTE temp2 = VMCode[CurrentIP++];
			BYTE Third = (temp2 >> 2) & 3;
			BYTE Second = (temp >> 4) & 0xf;
			BYTE First = temp2 & 3;

			ComparesonType = (temp2 >> 4) & 0x7;

			BYTE SecondArgument = temp & 0xf;
			BYTE SecondArgument_ = (temp >> 4) & 0xf;

			int ret = GetOperand((DWORD)VMCode, First, Second, Third);
			bool flag = 0;
			if (ret < 0) {
				ret = ret * -1;
				flag = 1;
			}

			BYTE SecondOperand = NULL;
			FinalCode += "  " + Registers[SecondArgument];

			printf("%p:  ", start);
			cout << FinalCode << "  ";
			if (flag)
				cout << "  " << Registers[ret] << "  " << endl;
			else
				printf("%x \n", ret);

		}
		break;

		case 0x07:	//JUMP
		{
			int start = CurrentIP;
			string FinalCode = Commands[1];
			CurrentIP++;
			BYTE FirstOperand = VMCode[CurrentIP++];
			DWORD JumpLocation = 0;
			JumpLocation = (DWORD)VMCode[CurrentIP];

			int ret = GetOperand((DWORD)VMCode, 0x2, 0x0, 0x2);
			if (ret < 0)ret = ret * -1;

			printf("%p:  ", start);

			cout << FinalCode << "  ";
			if (FirstOperand == 1) {
				cout << Conditional << " ";
				if (ComparesonType == 0) {
					cout << "JZ" << " ";
				}
				else if (ComparesonType == 1) {
					cout << "JNZ" << " ";
				}
				else if (ComparesonType == 2) {
					cout << "JNB" << " ";
				}
				ComparesonType = -1;
			}
			printf("%x \n", ret);
		}
		break;

		case 0x01:	//MOV
		{
			int start = CurrentIP;
			string FinalCode = Commands[2];
			CurrentIP++;

			int Third = (BYTE)(VMCode[CurrentIP + 1] >> 4) & 0x3;
			int Second_ = (BYTE)(VMCode[CurrentIP] >> 4) & 0xf;
			int First_ = (BYTE)(VMCode[CurrentIP + 1] & 0x3);



			BYTE First = VMCode[CurrentIP];
			CurrentIP++;
			CurrentIP++;
			int ret = GetOperand((DWORD)VMCode, First_, Second_, Third);

			if (!flag_) {
				ret = ret * -1;
			}
			int Disttenation = (BYTE)(First) & 0xf;

			printf("%p:  ", start);
			FinalCode += "  " + Registers[Disttenation] + "  ";
			cout << FinalCode << "  ";
			if (flag_) {
				printf("DATA_%x \n", ret);
				CurrentIP++;

			}
			else {
				cout << Registers[ret] << endl;;
			}
			flag_ = 1;
		}
		break;

		case 0x04:	//PUSh
		{
			int start = CurrentIP;
			string FinalCode = Commands[3];
			CurrentIP++;

			int First = (BYTE)(VMCode[CurrentIP] >> 4) & 0x3;
			int Second = (BYTE)(VMCode[CurrentIP]) & 0xf;
			int Third = (BYTE)(VMCode[CurrentIP] >> 6) & 0x3;

			CurrentIP++;

			int ret = GetOperand((DWORD)VMCode, First, Second, Third);
			if (ret < 0)ret = ret * -1;
			int Disttenation = (BYTE)(First) & 0xf;

			printf("%p:  ", start);
			cout << FinalCode << "  ";
			if (ret >= 0 && ret <= 15) {
				cout << Registers[ret] << endl;
			}
			else {
				printf("DATA_%x\n", ret);
			}
		}
		break;

		case 0x0d:	//CALL
		{
			int start = CurrentIP;
			string FinalCode = "CALL  ";
			CurrentIP++;

			BYTE FirstByte = VMCode[CurrentIP];
			BYTE SecondByte = VMCode[CurrentIP + 1];

			int First = (BYTE)(SecondByte) & 0x3;		
			int Second = (BYTE)(FirstByte) & 0xf;		
			int Third = 0x2;

			CurrentIP++;
			CurrentIP++;

			int ret = GetOperand((DWORD)VMCode, First, Second, Third);
			if (ret < 0)ret = ret * -1;

			Third = (BYTE)(SecondByte >> 4) & 0x3;
			Second = (BYTE)(FirstByte >> 4) & 0xf;
			First = (BYTE)(SecondByte >> 2) & 0x3;

			int ret_2 = GetOperand((DWORD)VMCode, First, Second, Third);	
			if (ret_2 < 0)ret_2 = ret_2 * (-1);

			CurrentIP++;

			int Disttenation = (BYTE)(First) & 0xf;
			printf("%p:  ", start);
			cout << FinalCode << endl;

		}
		break;

		case 0x0a:	//Arthimatic
		{
			int start = CurrentIP;
			string FinalCode = "";
			CurrentIP++;

			BYTE FirstByte = VMCode[CurrentIP];
			BYTE SecondByte = VMCode[CurrentIP + 1];

			CurrentIP++;
			CurrentIP++;

			BYTE TypeOfOperation = (BYTE)(SecondByte >> 4) & 0x7;
			switch (TypeOfOperation)
			{
			case 0x0:	//XOR
			{
				FinalCode += "XOR ";
			}
			break;
			case 0x1:	//ADD
			{
				FinalCode += "ADD ";
			}
			break;
			case 0x2:	//SUB
			{
				FinalCode += "SUB ";
			}
			break;
			case 0x3:	//shl
			{
				FinalCode += "shl ";
			}
			break;
			case 0x4:	//shr
			{
				FinalCode += "shr ";
			}
			case 0x5:	//ROL
			{
				FinalCode += "ROL ";
			}
			break;
			case 0x6:	//ROR
			{
				FinalCode += "ROR ";
			}
			break;
			case 0x7:	//div
			{
				FinalCode += "DIV ";
			}
			break;
			default:
				break;
			}

			int Disttenation = (BYTE)(FirstByte) & 0xf;
			FinalCode += Registers[Disttenation];
			FinalCode += "  ";

			int First = (BYTE)(SecondByte) & 0x3;
			int Second = (BYTE)(FirstByte >> 4) & 0xf;
			int Third = (BYTE)(SecondByte >> 2) & 0x3;
			bool flag = 0;
			int ret = GetOperand((DWORD)VMCode, First, Second, Third);
			if (ret <= 0) {
				flag = 1;
				ret = ret * -1;
			}


			printf("%p: ", start);
			cout << FinalCode << "  ";
			if (flag) {
				cout << Registers[ret] << endl;
			}
			else {
				printf("0x%x\n", ret);
				CurrentIP++;
				if (TypeOfOperation == 0x7)CurrentIP--;
			}

		}
		break;

		case 0x0B:	//Alocate and move to R0
		{
			int start = CurrentIP;
			string FinalCode = "MALLOC( ";
			CurrentIP++;

			BYTE FirstByte = VMCode[CurrentIP];

			int First = (BYTE)(FirstByte >> 4) & 0x3;;
			int Second = (BYTE)(FirstByte) & 0xf;
			int Third = (BYTE)(FirstByte >> 6) & 0x3;

			CurrentIP++;

			int ret = GetOperand((DWORD)VMCode, First, Second, Third);
			if (ret < 0)ret = ret * -1;


			int Disttenation = (BYTE)(First) & 0xf;
			printf("%p:  ", start);
			cout << "R0  " << FinalCode;
			printf("%x )\n", ret);

		}
		break;

		case 0x0c:	//CALL Kernel API
		{
			int start = CurrentIP;
			string FinalCode = "CALL Kernel API( ";
			CurrentIP++;

			BYTE FirstByte = VMCode[CurrentIP];

			int First = (BYTE)(FirstByte >> 4) & 0x3;;
			int Second = (BYTE)(FirstByte) & 0xf;
			int Third = (BYTE)(FirstByte >> 6) & 0x3;

			CurrentIP++;

			int ret = GetOperand((DWORD)VMCode, First, Second, Third);
			if (ret < 0)ret = ret * -1;


			int Disttenation = (BYTE)(First) & 0xf;
			printf("%p: ", start);
			cout << FinalCode << "  " << Registers[ret] << " )" << endl;

		}
		case 0x00:	//BREAK out of VM code (ret)
		{
			int start = CurrentIP;
			string FinalCode = "Ret";
			CurrentIP++;
			printf("%p: ", start);
			cout << FinalCode << endl;

		}
		break;

		default:
			printf("UNKNOWN\n");
			CurrentIP++;
			break;
		}

	}

}





int GetOperand(DWORD baseofCode, int First, int Second, int Third)
{
	int v5;

	v5 = 0;
	if (First)
	{
		switch (First)
		{
		case 1:
			if (Third)
			{
				if (Third == 1)
				{
					v5 = -1 * Second;
					flag_ = 0;
				}
				else if (Third == 2)
				{
					v5 = -1 * Second;
					flag_ = 0;
				}
			}
			else
			{
				v5 = -1 * Second;
				flag_ = 0;
			}
			break;
		case 2:
			if (Third)
			{
				if (Third == 1)
				{
					v5 = 0x0;
					v5 = VMCode[CurrentIP + 1];
					v5 = ((v5 << 8) | VMCode[CurrentIP]);
					CurrentIP += 2;
				}
				else if (Third == 2)
				{
					v5 = 0;
					v5 = VMCode[CurrentIP + 3];
					v5 = ((v5 << 8) | VMCode[CurrentIP + 2]);
					v5 = ((v5 << 8) | VMCode[CurrentIP + 1]);
					v5 = ((v5 << 8) | VMCode[CurrentIP]);
					CurrentIP += 4;
				}
			}
			else
			{
				v5 = (BYTE)VMCode[CurrentIP];
				//CurrentIP++;
			}
			break;
		case 3:
			//data :add 2 to ip
			v5 = 0;
			v5 = VMCode[CurrentIP + 3];
			v5 = ((v5 << 8) | VMCode[CurrentIP + 2]);
			v5 = ((v5 << 8) | VMCode[CurrentIP + 1]);
			v5 = ((v5 << 8) | VMCode[CurrentIP]);
			CurrentIP += 4;
			break;
		}
	}
	else if (Third)
	{
		if (Third == 1)
		{
			v5 = -1 * Second;
			flag_ = 0;
		}
		else if (Third == 2)
		{
			v5 = -1 * Second;
			flag_ = 0;
		}
	}
	else
	{
		v5 = -1 * Second;
		flag_ = 0;
	}
	return v5;
}